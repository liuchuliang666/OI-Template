**历史和线段树**就是能在 $O(n\log n)$ 中查询过去 $q$ 个版本某个区间的和的总和。

形式化的说，有一个数组 $a$ 和一个辅助数组 $b$，每一次（广义）更新操作都会执行 $a:[x,y] \rightarrow b:[x,y]$，查询 $k$ 个版本后 $b:[x,y]$ 的值（即 $\sum\limits_{k}\sum\limits_{i = x}^y a_i$ 的值）。

### 矩阵法求解历史和

如何在 $O(n\log n)$ 的时间内解决上述问题呢？

我们考虑使用线段树和矩阵。

???+ question "[LOJ193 【模板】线段树历史和](https://loj.ac/p/193)"
    这是一道模板题。

    您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：

    1. 区间加一个数；
    2. 查询区间的历史和；

    历史和定义为数列 $h_i$ 的区间和：初始 $h_i=a_i$，在每次操作（修改或查询，具体可参考样例解释）完成后，对所有 $h_i \leftarrow h_i+a_i$。

以 LOJ193 为例，我们要求最朴素的历史和。

我们可以用线段树维护矩阵，其中矩阵为：

$$
\begin{bmatrix}
    his \\
    sum \\
    len
\end{bmatrix}
$$

其中 $his$ 为历史和，$sum$ 为区间和，$len$ 为区间长度。

其实就是用矩阵打包线段树上要维护的所有变量。

对于叶子节点，$len = 1$,$sum = a_i$，$his = 0$；对于非叶子节点，$tag = \begin{bmatrix}
    1 & 0 & 0\\
    0 & 1 & 0\\
    0 & 0 & 1\\
\end{bmatrix}$。

然后是对线段树进行区间矩阵乘操作：

节点的合并（例节点 $a + b \rightarrow c$）:

$$
\begin{bmatrix}
    his_a \\
    sum_a \\
    len_a
\end{bmatrix}
+
\begin{bmatrix}
    his_b \\
    sum_b \\
    len_b
\end{bmatrix}
=
\begin{bmatrix}
    his_c \\
    sum_c \\
    len_c
\end{bmatrix}
$$

区间加 $d$ 操作为：

$$
\begin{bmatrix}
    1 & 0 & 0 \\
    0 & 1 & d \\
    0 & 0 & 1 \\
\end{bmatrix}
\times
\begin{bmatrix}
    his \\
    sum \\
    len
\end{bmatrix}
=
\begin{bmatrix}
    his \\
    sum + d \times len \\
    len
\end{bmatrix}
$$

区间历史和更新操作为：

$$
\begin{bmatrix}
    1 & 1 & 0 \\
    0 & 1 & 0 \\
    0 & 0 & 1 \\
\end{bmatrix}
\times
\begin{bmatrix}
    his \\
    sum \\
    len
\end{bmatrix}
=
\begin{bmatrix}
    his + sum \\
    sum \\
    len
\end{bmatrix}
$$

我们将矩阵按线段树的方式下放到指定区间即可。

我们每次进行区间加 $d$ 时，对**全局进行历史和更新操作**。

最后查询区间矩阵的历史和，只需按线段树的方式求区间矩阵的 $\sum his$ 即可。

这样你就成功完成了此题！

??? code "实现"
    ```cpp
    --8<-- "docs/DS/code/loj1931.cpp"
    ```

通过记录：![accept?](https://cdn.luogu.com.cn/upload/image_hosting/bbugqk2y.png)

#### 进一步优化

我们的矩阵乘法要维护两个 $3 \times 3$ 矩阵相乘的结果，这带来的结果是常数来到了惊人的 $27$，然而这是无法接受的！

这时聪明的奶龙就发现了，**矩阵的好多地方是不变的**！

我们可以用下面的代码来探究到底哪些矩阵元素永远不会变：

??? "探究随机矩阵乘所固定的元素"
    ```cpp
    --8<-- "docs/DS/code/hist.cpp"
    ```

我们会惊讶的发现，实际上矩阵中只有四个位置是在变化的：

$$
\begin{bmatrix}
    1 & a & b \\
    0 & c & d \\
    0 & 0 & 1 \\
\end{bmatrix}
$$

那么，我们可以通过手摸矩阵来达到 $3 \sim 4$ 的复杂度常数！

??? code "实现"
    ```cpp
    --8<-- "docs/DS/code/loj1932.cpp"
    ```

通过记录：![accept!](https://cdn.luogu.com.cn/upload/image_hosting/7vx7c1md.png)

可以看到区别还是很大的！

### 推理法求历史和
待后人补充！

### 值得注意的事情

矩阵所维护的元素所执行的操作无非**加减乘除**，这是矩阵的作为线性代数的性质导致的。

也就是说，历史和线段树只能用来维护**具有线性关系**的元素！

所有对于一类历史和线段树问题，思路都是尝试转换成一系列线性关系的操作。

### 习题

[codeforces 1824D: LuoTianyi and the Function](https://codeforces.com/contest/1824/problem/D)
> [codeforces 1824D 题解](https://www.luogu.com.cn/article/nphp6yhn)

[NOIP2022 比赛](https://www.luogu.com.cn/problem/P8868)