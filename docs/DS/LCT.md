???+ question "[P3690 【模板】动态树（LCT）](https://www.luogu.com.cn/problem/P3690)"
    给定 $n$ 个点以及每个点的权值，要你处理接下来的 $m$ 个操作。
    操作有四种，操作从 $0$ 到 $3$ 编号。点从 $1$ 到 $n$ 编号。

    - `0 x y` 代表询问从 $x$ 到 $y$ 的路径上的点的权值的 $\text{xor}$ 和。保证 $x$ 到 $y$ 是联通的。
    - `1 x y` 代表连接 $x$ 到 $y$，若 $x$ 到 $y$ 已经联通则无需连接。
    - `2 x y` 代表删除边 $(x,y)$，不保证边 $(x,y)$ 存在。
    - `3 x y` 代表将点 $x$ 上的权值变成 $y$。

    对于全部的测试点，保证：

    - $1 \leq n \leq 10^5$，$1 \leq m \leq 3 \times 10^5$，$1 \leq a_i \leq 10^9$。
    - 对于操作 $0, 1, 2$，保证 $1 \leq x, y \leq n$。
    - 对于操作 $3$，保证 $1 \leq x \leq n$，$1 \leq y \leq 10^9$。

## 用途

LCT(Link Cut Tree) 是一种用于处理一个有根的森林中各棵树之间的动态操作。LCT 能维护动态树的的平衡性，以 $O(\log n)$ 的均摊复杂度进行合并、删除、查询等操作。

## LCT 的思想

LCT 结合了树链剖分和 Splay 树的思路。其核心思想为 **“原树实链从上到下，对应 Splay 树从左到右”**。

1. 实链剖分
2. 转换原树为辅助树，用辅助树维护原树，在代码中只需维护辅助树。
3. LCT 借用了 Splay 树的操作方法处理实链。

## 从原树到辅助树

1. 将原树剖分为实链和虚边
2. 将原树转换为为辅助树，实链和虚边
3. 用 Splay 树处理实链（节点在 Splay 中的优先级为原树上节点的深度）

![](./images/lct-access-1.svg)

转化为

![](./images/lct-access-2.svg)

## LCT 的性质

1. 辅助树表达原树的路径形态。
2. 原树的一条实链对应辅助树上的一颗 Splay 树。
3. 原树实链从上到下，对应 Splay 树从左到右。
4. 辅助树中的各棵 Splay 树用虚边链接。

## LCT 的操作

1. `isrt(x)` ：判断 $x$ 是否为它所在的 Splay 树的根。

    ???+ code "实现"
        ```cpp
        --8<-- "docs/DS/code/lct.cpp:12:16"
        ```

2. `splay(x)` ：将辅助树的节点 $x$ 转到其所在 Splay 树的根，操作并不影响原树。

    ???+ code "实现"
        ```cpp
        --8<-- "docs/DS/code/lct.cpp:51:68"
        ```

3. `access(x)` ：在原树上创建一条从根到节点 $x$ 的实链，即辅助树上一颗 Splay。

    ???+ code "实现"
        ```cpp
        --8<-- "docs/DS/code/lct.cpp:69:77"
        ```

4. `makert(x)` ：把 $x$ 在原树上旋转到根的位置。

    ???+ code "实现"
        ```cpp
        --8<-- "docs/DS/code/lct.cpp:78:83"
        ```

5. `findrt(x)` ：查找 $x$ 在原树上的根，常用于判断两节点是否连通。

    ???+ code "实现"
        ```cpp
        --8<-- "docs/DS/code/lct.cpp:102:108"
        ```

6. `split(x, y)` ：在原树上生成一条 $x$ 到 $y$ 的实链。

    ???+ code "实现"
        ```cpp
        --8<-- "docs/DS/code/lct.cpp:84:89"
        ```

7. `link(x, y)` ：连接 $x$ 和 $y$。

    ???+ code "实现"
        ```cpp
        --8<-- "docs/DS/code/lct.cpp:90:94"
        ```

8. `cut(x, y)` ：断开 $x$ 和 $y$。

    ???+ code "实现"
        ```cpp
        --8<-- "docs/DS/code/lct.cpp:95:101"
        ```

## 总实现

??? code "实现"
    ```cpp
    --8<-- "docs/DS/code/lct.cpp"
    ```

## LCT 的应用

1. 判断连通性。
2. 求两点距离。
3. 求 LCA。

## 习题

???+ question "[P2147 [SDOI2008] 洞穴勘测](https://www.luogu.com.cn/problem/P2147)"
    辉辉热衷于洞穴勘测。

    某天，他按照地图来到了一片被标记为JSZX的洞穴群地区。经过初步勘测，辉辉发现这片区域由$n$个洞穴（分别编号为$1$到$n$）以及若干通道组成，并且每条通道连接了恰好两个洞穴。假如两个洞穴可以通过一条或者多条通道按一定顺序连接起来，那么这两个洞穴就是连通的，按顺序连接在一起的这些通道则被称之为这两个洞穴之间的一条路径。 洞穴都十分坚固无法破坏，然而通道不太稳定，时常因为外界影响而发生改变，比如，根据有关仪器的监测结果，$123$号洞穴和$127$号洞穴之间有时会出现一条通道，有时这条通道又会因为某种稀奇古怪的原因被毁。

    辉辉有一台监测仪器可以实时将通道的每一次改变状况在辉辉手边的终端机上显示：

    - 如果监测到洞穴$u$和洞穴$v$之间出现了一条通道，终端机上会显示一条指令 `Connect u v`；

    - 如果监测到洞穴$u$和洞穴$v$之间的通道被毁，终端机上会显示一条指令 `Destroy u v`。

    经过长期的艰苦卓绝的手工推算，辉辉发现一个奇怪的现象：无论通道怎么改变，任意时刻任意两个洞穴之间至多只有一条路径。

    因而，辉辉坚信这是由于某种本质规律的支配导致的。因而，辉辉更加夜以继日地坚守在终端机之前，试图通过通道的改变情况来研究这条本质规律。 然而，终于有一天，辉辉在堆积成山的演算纸中崩溃了……他把终端机往地面一砸（终端机也足够坚固无法破坏），转而求助于你，说道：“你老兄把这程序写写吧”。

    辉辉希望能随时通过终端机发出指令 `Query u v`，向监测仪询问此时洞穴$u$和洞穴$v$是否连通。现在你要为他编写程序回答每一次询问。 已知在第一条指令显示之前，JSZX洞穴群中没有任何通道存在。

    $100\%$的数据满足 $n \leq 10000, m \leq 200000$。

    保证所有 `Destroy` 指令将摧毁的是一条存在的通道。

    本题输入、输出规模比较大，建议c/c++选手使用`scanf`和`printf`进行I/O操作以免超时。

??? question "[P4312 [COI 2009] OTOCI](https://www.luogu.com.cn/problem/P4312)"
    不久之前，Mirko 建立了一个旅行社，名叫“极地之梦”。这家旅行社在北极附近购买了 $n$ 座冰岛，并且提供观光服务。

    当地最受欢迎的当然是帝企鹅了，这些小家伙经常成群结队的游走在各个冰岛之间。Mirko 的旅行社遭受一次重大打击，以至于观光游轮已经不划算了。旅行社将在冰岛之间建造大桥，并用观光巴士来运载游客。

    Mirko 希望开发一个电脑程序来管理这些大桥的建造过程，以免有不可预料的错误发生。这些冰岛从1到N标号。一开始时这些岛屿没有大桥连接，并且所有岛上的帝企鹅数量都是知道的。每座岛上的企鹅数量虽然会有所改变，但是始终在 $[0, 1000]$ 之间。你的程序需要处理以下三种命令：

    - `bridge u v`：询问结点 $u$ 与结点 $v$ 是否连通。如果是则输出 `no`；否则输出 `yes`，并且在结点 $u$ 和结点 $v$ 之间连一条无向边。
    - `penguins u x`：将结点 $u$ 对应的权值 $w_u$ 修改为 $x$。
    - `excursion u v`：如果结点 $u$ 和结点 $v$ 不连通，则输出 `impossible`。否则输出结点 $u$ 到结点 $v$ 的路径上的点对应的权值的和。

    共有 $q$ 个操作。

    对于 $100\%$ 的数据，$1 \le n \le 3 \times 10^4$，$1 \le q \le 3\times 10^5$, $0 \le w_i \le 1000$。


??? question "[P1501 [国家集训队] Tree II](https://www.luogu.com.cn/problem/P1501)"
    一棵 $n$ 个点的树，每个点的初始权值为 $1$。
    对于这棵树有 $q$ 个操作，每个操作为以下四种操作之一：

    - `+ u v c`：将 $u$ 到 $v$ 的路径上的点的权值都加上自然数 $c$；
    - `- u1 v1 u2 v2`：将树中原有的边 $(u_1,v_1)$ 删除，加入一条新边 $(u_2,v_2)$，保证操作完之后仍然是一棵树；
    - `* u v c`：将 $u$ 到 $v$ 的路径上的点的权值都乘上自然数 $c$；
    - `/ u v`：询问 $u$ 到 $v$ 的路径上的点的权值和，将答案对 $51061$ 取模。

    对于 $100\%$ 的数据，$1\le n,q \le 10^5$，$0\le c \le 10^4$。
