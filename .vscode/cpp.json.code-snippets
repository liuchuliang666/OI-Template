{
    // Place your snippets for cpp here. Each snippet is defined under x snippet name and has x prefix, body and
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
    // same ids are connected.
    // Example:
    // "Print to console": {
    //     "prefix": "log",
    //     "body": [
    //     "console.log('$1');",
    //     "$2"
    //     ],
    //     "description": "Log output to console"
    // }
    "template": {
        "prefix": "```ctemplate",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "int main(int argc, char **argv) {",
            "    $0",
            "    return 0;",
            "}",
        ],
        "description": "template"
    },
    "OI": {
        "prefix": "```cpp",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define TEMPTK template <typename T = long long, typename K = long long>",
            "#ifdef ONLINE_JUDGE",
            "#define debug(...) (0)",
            "struct __CERR {",
            "    TEMPTK __CERR &operator<<(const T &x) { return *this; }",
            "} __cerr;",
            "#define cerr __cerr",
            "#define endl '\\n'",
            "#else",
            "#define debug(...) fprintf(stderr, ##__VA_ARGS__)",
            "#endif",
            "#ifdef CPH",
            "#define freopen(...) (0)",
            "#define endl '\\n'",
            "#endif",
            "#ifdef _WIN32",
            "#define gc _getchar_nolock",
            "#define pc _putchar_nolock",
            "#else",
            "#define gc getchar_unlocked",
            "#define pc putchar_unlocked",
            "#endif",
            "#define ef emplace_front",
            "#define eb emplace_back",
            "#define ep emplace",
            "#define pb push_back",
            "#define ins insert",
            "#define fi first",
            "#define se second",
            "#define ALL(x) (x).begin(), (x).end()",
            "#define rep(i, l, r, ...) for (int i = int(l), ##__VA_ARGS__; i <= int(r); ++i)",
            "#define per(i, r, l, ...) for (int i = int(r), ##__VA_ARGS__; i >= int(l); --i)",
            "#define Rep(i, l, r, ...) for (int i = int(l), i##e = int(r), ##__VA_ARGS__; i <= i##e; ++i)",
            "#define Per(i, r, l, ...) for (int i = int(r), i##e = int(l), ##__VA_ARGS__; i >= i##e; --i)",
            "#define repl(i, l, r, ...) for (long long i = (long long)(l), ##__VA_ARGS__; i <= (long long)(r); ++i)",
            "#define perl(i, r, l, ...) for (long long i = (long long)(r), ##__VA_ARGS__; i >= (long long)(l); --i)",
            "#define Repl(i, l, r, ...) for (long long i = (long long)(l), i##e = (long long)(r), ##__VA_ARGS__; i <= i##e; ++i)",
            "#define Perl(i, r, l, ...) for (long long i = (long long)(r), i##e = (long long)(l), ##__VA_ARGS__; i >= i##e; --i)",
            "#define Mst(x, val, len) memset(x, val, sizeof((x)[0]) * int(len))",
            "#define Mcp(from, to, len) memcpy(to, from, sizeof((to)[0]) * int(len))",
            "#define mst(x, val) memset(x, val, sizeof(x))",
            "#define mcp(from, to) memcpy(to, from, sizeof(from))",
            "#define mid ((l) + (((r) - (l)) >> 1))",
            "#define ls ((x) << 1)",
            "#define rs ((x) << 1 | 1)",
            "#define lson ls, l, mid",
            "#define rson rs, mid + 1, r",
            "#define pbds __gnu_pbds",
            "using ll = long long;",
            "using ull = unsigned long long;",
            "using db = double;",
            "using i128 = __int128;",
            "using ld = long double;",
            "using vi = vector<int>;",
            "using vii = vector<vi>;",
            "using pii = pair<int, int>;",
            "using vpii = vector<pii>;",
            "using vl = vector<ll>;",
            "using vll = vector<vi>;",
            "using pll = pair<ll, ll>;",
            "using vpll = vector<pll>;",
            "namespace LCL {",
            "    mt19937_64 rnd(random_device{}());",
            "    constexpr int INFI = numeric_limits<int>::max(), infi = 1e9 + 7;",
            "    constexpr ll INFL = numeric_limits<ll>::max(), infl = 1e15 + 7;",
            "    constexpr ll P = 998244353;",
            "    constexpr auto Bit = [](const auto &x) { return 1ll << x; };",
            "    const auto cins = [](auto &...x) { ((cin >> x), ...); };",
            "    const auto couts = [](const auto &...x) { ((cout << x << ' '), ...) << endl; };",
            "    const auto cerrs = [](const auto &...x) { ((cerr << x << ' '), ...) << endl; };",
            "    const auto SZ = [](const auto &x) -> int { return x.size(); };",
            "    const auto swap = [](auto &x, auto &y) {",
            "        if constexpr (is_integral_v<decltype(x)>)",
            "            x ^= y ^= x ^= y;",
            "        else",
            "            std::swap(x, y);",
            "    };",
            "    constexpr auto min = [](auto x, const auto &...y) { return ((x = x < y ? x : y), ...); };",
            "    constexpr auto max = [](auto x, const auto &...y) { return ((x = x < y ? y : x), ...); };",
            "    const auto &chkmn = [](auto &x, const auto &...y) { return ((x = x < y ? x : y), ...); };",
            "    const auto &chkmx = [](auto &x, const auto &...y) { return ((x = x < y ? y : x), ...); };",
            "    const auto abs = [](const auto &x) { return x < 0 ? -x : x; };",
            "    const auto lowb = [](const auto &x) { return x & (-x); };",
            "    const auto isdigit = [](const char &c) { return c >= '0' && c <= '9'; };",
            "    const auto &add = [](auto &x, const auto &y) { return ((x += y) >= P ? x -= P : x); };",
            "    const auto tadd = [](auto x, const auto &y) { return add(x, y); };",
            "    const auto tmul = [](const auto &x, const auto &y) { return x * y % P; };",
            "    const auto &mul = [](auto &x, const auto &y) { return x = tmul(x, y); };",
            "    const auto cmod = [](auto x) { return (x %= P) += x >> 31 & P; };",
            "    const auto qmul = [](auto x, const auto &y) { return (x = (ull)x * y - (ull)((ld)x / P * y) * P) += x >> 31 & P; };",
            "    const auto &Add = [](auto &x, const auto &y) { return x = cmod(x + y); };",
            "    const auto &Mul = [](auto &x, const auto &y) { return x = qmul(x, y); };",
            "} // namespace LCL",
            "// #define int ll",
            "int c, T = 1;",
            "namespace LCL {",
            "    constexpr int MAXN = 2e5 + 10, MAXV = MAXN << 2;",
            "    void main() {",
            "        $0",
            "    }",
            "} // namespace LCL",
            "signed main() {",
            "    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
            "    // cin >> T;",
            "    while (T--) LCL::main();",
            "    return 0;",
            "}",
        ]
    },
    "define": {
        "prefix": "```def",
        "body": [
            "#define TEMPTK template <typename T = int, typename K = int>",
            "#ifdef ONLINE_JUDGE",
            "#define debug(...) (0)",
            "struct __CERR {",
            "    TEMPTK __CERR &operator<<(const T &x) { return *this; }",
            "} __cerr;",
            "#define cerr __cerr",
            "#define endl '\\n'",
            "#else",
            "#define debug(...) fprintf(stderr, ##__VA_ARGS__)",
            "#endif",
            "#ifdef CPH",
            "#define freopen(...) (0)",
            "#define endl '\\n'",
            "#endif",
            "#ifdef _WIN32",
            "#define gc _getchar_nolock",
            "#define pc _putchar_nolock",
            "#else",
            "#define gc getchar_unlocked",
            "#define pc putchar_unlocked",
            "#endif",
            "#define ef emplace_front",
            "#define eb emplace_back",
            "#define ep emplace",
            "#define pb push_back",
            "#define ins insert",
            "#define fi first",
            "#define se second",
            "#define ALL(x) (x).begin(), (x).end()",
            "#define rep(i, l, r, ...) for (int i = int(l), ##__VA_ARGS__; i <= int(r); ++i)",
            "#define per(i, r, l, ...) for (int i = int(r), ##__VA_ARGS__; i >= int(l); --i)",
            "#define Rep(i, l, r, ...) for (int i = int(l), i##e = int(r), ##__VA_ARGS__; i <= i##e; ++i)",
            "#define Per(i, r, l, ...) for (int i = int(r), i##e = int(l), ##__VA_ARGS__; i >= i##e; --i)",
            "#define repl(i, l, r, ...) for (long long i = (long long)(l), ##__VA_ARGS__; i <= (long long)(r); ++i)",
            "#define perl(i, r, l, ...) for (long long i = (long long)(r), ##__VA_ARGS__; i >= (long long)(l); --i)",
            "#define Repl(i, l, r, ...) for (long long i = (long long)(l), i##e = (long long)(r), ##__VA_ARGS__; i <= i##e; ++i)",
            "#define Perl(i, r, l, ...) for (long long i = (long long)(r), i##e = (long long)(l), ##__VA_ARGS__; i >= i##e; --i)",
            "#define Mst(x, val, len) memset(x, val, sizeof((x)[0]) * int(len))",
            "#define Mcp(from, to, len) memcpy(to, from, sizeof((to)[0]) * int(len))",
            "#define mst(x, val) memset(x, val, sizeof(x))",
            "#define mcp(from, to) memcpy(to, from, sizeof(from))",
            "#define mid ((l) + (((r) - (l)) >> 1))",
            "#define ls ((x) << 1)",
            "#define rs ((x) << 1 | 1)",
            "#define lson ls, l, mid",
            "#define rson rs, mid + 1, r",
            "#define pbds __gnu_pbds",
            "using ll = long long;",
            "using ull = unsigned long long;",
            "using db = double;",
            "using i128 = __int128;",
            "using ld = long double;",
            "using vi = vector<int>;",
            "using vii = vector<vi>;",
            "using pii = pair<int, int>;",
            "using vpii = vector<pii>;",
            "using vl = vector<ll>;",
            "using vll = vector<vi>;",
            "using pll = pair<ll, ll>;",
            "using vpll = vector<pll>;",
            "namespace LCL {",
            "    mt19937_64 rnd(random_device{}());",
            "    constexpr int INFI = numeric_limits<int>::max(), infi = 1e9 + 7;",
            "    constexpr ll INFL = numeric_limits<ll>::max(), infl = 1e15 + 7;",
            "    constexpr ll P = 998244353;",
            "    constexpr auto Bit = [](const auto &x) { return 1ll << x; };",
            "    const auto cins = [](auto &...x) { ((cin >> x), ...); };",
            "    const auto couts = [](const auto &...x) { ((cout << x << ' '), ...) << endl; };",
            "    const auto cerrs = [](const auto &...x) { ((cerr << x << ' '), ...) << endl; };",
            "    const auto SZ = [](const auto &x) -> int { return x.size(); };",
            "    const auto swap = [](auto &x, auto &y) {",
            "        if constexpr (is_integral_v<decltype(x)>)",
            "            x ^= y ^= x ^= y;",
            "        else",
            "            std::swap(x, y);",
            "    };",
            "    constexpr auto min = [](auto x, const auto &...y) { return ((x = x < y ? x : y), ...); };",
            "    constexpr auto max = [](auto x, const auto &...y) { return ((x = x < y ? y : x), ...); };",
            "    const auto &chkmn = [](auto &x, const auto &...y) { return ((x = x < y ? x : y), ...); };",
            "    const auto &chkmx = [](auto &x, const auto &...y) { return ((x = x < y ? y : x), ...); };",
            "    const auto abs = [](const auto &x) { return x < 0 ? -x : x; };",
            "    const auto lowb = [](const auto &x) { return x & (-x); };",
            "    const auto isdigit = [](const char &c) { return c >= '0' && c <= '9'; };",
            "    const auto &add = [](auto &x, const auto &y) { return ((x += y) >= P ? x -= P : x); };",
            "    const auto tadd = [](auto x, const auto &y) { return add(x, y); };",
            "    const auto tmul = [](const auto &x, const auto &y) { return x * y % P; };",
            "    const auto &mul = [](auto &x, const auto &y) { return x = tmul(x, y); };",
            "    const auto cmod = [](auto x) { return (x %= P) += x >> 31 & P; };",
            "    const auto qmul = [](auto x, const auto &y) { return (x = (ull)x * y - (ull)((ld)x / P * y) * P) += x >> 31 & P; };",
            "    const auto &Add = [](auto &x, const auto &y) { return x = cmod(x + y); };",
            "    const auto &Mul = [](auto &x, const auto &y) { return x = qmul(x, y); };",
            "} // namespace LCL",
            "// #define int ll",
        ]
    },
    "defination for leetcode": {
        "prefix": "```leetcode",
        "body": [
            "#define TEMPTK template <typename T = int, typename K = int>",
            "#define ef emplace_front",
            "#define eb emplace_back",
            "#define ep emplace",
            "#define pb push_back",
            "#define ins insert",
            "#define fi first",
            "#define se second",
            "#define ALL(x) (x).begin(), (x).end()",
            "#define rep(i, l, r, ...) for (int i = int(l), ##__VA_ARGS__; i <= int(r); ++i)",
            "#define per(i, r, l, ...) for (int i = int(r), ##__VA_ARGS__; i >= int(l); --i)",
            "#define Rep(i, l, r, ...) for (int i = int(l), i##e = int(r), ##__VA_ARGS__; i <= i##e; ++i)",
            "#define Per(i, r, l, ...) for (int i = int(r), i##e = int(l), ##__VA_ARGS__; i >= i##e; --i)",
            "#define repl(i, l, r, ...) for (long long i = (long long)(l), ##__VA_ARGS__; i <= (long long)(r); ++i)",
            "#define perl(i, r, l, ...) for (long long i = (long long)(r), ##__VA_ARGS__; i >= (long long)(l); --i)",
            "#define Repl(i, l, r, ...) for (long long i = (long long)(l), i##e = (long long)(r), ##__VA_ARGS__; i <= i##e; ++i)",
            "#define Perl(i, r, l, ...) for (long long i = (long long)(r), i##e = (long long)(l), ##__VA_ARGS__; i >= i##e; --i)",
            "#define Mst(x, val, len) memset(x, val, sizeof((x)[0]) * int(len))",
            "#define Mcp(from, to, len) memcpy(to, from, sizeof((to)[0]) * int(len))",
            "#define mst(x, val) memset(x, val, sizeof(x))",
            "#define mcp(from, to) memcpy(to, from, sizeof(from))",
            "#define mid ((l) + (((r) - (l)) >> 1))",
            "#define ls ((x) << 1)",
            "#define rs ((x) << 1 | 1)",
            "#define lson ls, l, mid",
            "#define rson rs, mid + 1, r",
            "using ll = long long;",
            "using ull = unsigned long long;",
            "using db = double;",
            "using i128 = __int128;",
            "using ld = long double;",
            "using vi = vector<int>;",
            "using vii = vector<vi>;",
            "using pii = pair<int, int>;",
            "using vpii = vector<pii>;",
            "using vl = vector<ll>;",
            "using vll = vector<vi>;",
            "using pll = pair<ll, ll>;",
            "using vpll = vector<pll>;",
            "namespace LCL {",
            "    mt19937_64 rnd(random_device{}());",
            "    constexpr int INFI = numeric_limits<int>::max(), infi = 1e9 + 7;",
            "    constexpr ll INFL = numeric_limits<ll>::max(), infl = 1e15 + 7;",
            "    constexpr ll P = 998244353;",
            "    constexpr auto Bit = [](const auto &x) { return 1ll << x; };",
            "    const auto cins = [](auto &...x) { ((cin >> x), ...); };",
            "    const auto couts = [](const auto &...x) { ((cout << x << ' '), ...) << endl; };",
            "    const auto cerrs = [](const auto &...x) { ((cerr << x << ' '), ...) << endl; };",
            "    const auto SZ = [](const auto &x) -> int { return x.size(); };",
            "    const auto swap = [](auto &x, auto &y) {",
            "        if constexpr (is_integral_v<decltype(x)>)",
            "            x ^= y ^= x ^= y;",
            "        else",
            "            std::swap(x, y);",
            "    };",
            "    constexpr auto min = [](auto x, const auto &...y) { return ((x = x < y ? x : y), ...); };",
            "    constexpr auto max = [](auto x, const auto &...y) { return ((x = x < y ? y : x), ...); };",
            "    const auto &chkmn = [](auto &x, const auto &...y) { return ((x = x < y ? x : y), ...); };",
            "    const auto &chkmx = [](auto &x, const auto &...y) { return ((x = x < y ? y : x), ...); };",
            "    const auto abs = [](const auto &x) { return x < 0 ? -x : x; };",
            "    const auto lowb = [](const auto &x) { return x & (-x); };",
            "    const auto isdigit = [](const char &c) { return c >= '0' && c <= '9'; };",
            "    const auto &add = [](auto &x, const auto &y) { return ((x += y) >= P ? x -= P : x); };",
            "    const auto tadd = [](auto x, const auto &y) { return add(x, y); };",
            "    const auto tmul = [](const auto &x, const auto &y) { return x * y % P; };",
            "    const auto &mul = [](auto &x, const auto &y) { return x = tmul(x, y); };",
            "    const auto cmod = [](auto x) { return (x %= P) += x >> 31 & P; };",
            "    const auto qmul = [](auto x, const auto &y) { return (x = (ull)x * y - (ull)((ld)x / P * y) * P) += x >> 31 & P; };",
            "    const auto &Add = [](auto &x, const auto &y) { return x = cmod(x + y); };",
            "    const auto &Mul = [](auto &x, const auto &y) { return x = qmul(x, y); };",
            "} // namespace LCL",
            "using LCL::Solution;"
        ]
    },
    "matrix": {
        "prefix": "```mat",
        "body": [
            "TEMPTK struct Mat {",
            "    vector<vector<T>> val;",
            "    int n, m;",
            "    vector<T> &operator[](int x) { return val[x]; }",
            "    Mat(int n = 0, int m = 0) : n(n), m(m), val(n + 1, vector<T>(m + 1, 0)) {}",
            "    friend Mat<T> operator*(Mat<T> x, Mat<T> y) {",
            "        Mat<T> z(x.n, y.m);",
            "        // init",
            "        rep(i, 1, x.n) rep(k, 1, x.m) rep(j, 1, y.m) /* oper(z[i][j], x[i][k] ? y[k][j])*/;",
            "        return z;",
            "    }",
            "};",
            "TEMPTK Mat<T> qpow(Mat<T> x, ll y) {",
            "    Mat<T> res(x.n, x.m);",
            "    for (/* res.init() */; y; y >>= 1, x = x * x)",
            "        if (y & 1) res = res * x;",
            "    return res;",
            "}",
        ]
    },
    "pow of number": {
        "prefix": "```pnum",
        "body": [
            "TEMPTK struct NumPow {",
            "    vector<T> val;",
            "    NumPow(ll x, int N) : val(N + 1) {",
            "        val[0] = 1;",
            "        rep(i, 1, N) val[i] = tmul(val[i - 1], x);",
            "    }",
            "    const T &operator[](int x) const { return val[x]; }",
            "};",
        ]
    },
    "Triangle of Yang": {
        "prefix": "```yangt",
        "body": [
            "TEMPTK struct YangTriangle {",
            "    vector<vector<T>> C;",
            "    YangTriangle(int N) : C(N + 1, vector<T>(N + 1)){",
            "        rep(i, 0, N) {",
            "            C[i][0] = 1;",
            "            rep(j, 1, i) C[i][j] = tadd(C[i - 1][j - 1], C[i - 1][j]);",
            "        }",
            "    }",
            "    const vector<T>& operator[](int x) const { return C[x]; }",
            "};",
        ]
    },
    "rep": {
        "prefix": "```rep",
        "body": [
            "#define rep(i, l, r, ...) for (int i = int(l), ##__VA_ARGS__; i <= int(r); ++i)",
            "#define per(i, r, l, ...) for (int i = int(r), ##__VA_ARGS__; i >= int(l); --i)",
            "#define Rep(i, l, r, ...) for (int i = int(l), i##e = int(r), ##__VA_ARGS__; i <= i##e; ++i)",
            "#define Per(i, r, l, ...) for (int i = int(r), i##e = int(l), ##__VA_ARGS__; i >= i##e; --i)",
            "#define repl(i, l, r, ...) for (long long i = (long long)(l), ##__VA_ARGS__; i <= (long long)(r); ++i)",
            "#define perl(i, r, l, ...) for (long long i = (long long)(r), ##__VA_ARGS__; i >= (long long)(l); --i)",
            "#define Repl(i, l, r, ...) for (long long i = (long long)(l), i##e = (long long)(r), ##__VA_ARGS__; i <= i##e; ++i)",
            "#define Perl(i, r, l, ...) for (long long i = (long long)(r), i##e = (long long)(l), ##__VA_ARGS__; i >= i##e; --i)",
        ]
    },
    "header": {
        "prefix": "```head",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
        ]
    },
    "freopen": {
        "prefix": "```fre",
        "body": [
            "freopen(\"${1:${TM_FILENAME_BASE}}.in\", \"r\", stdin);",
            "freopen(\"${1:${TM_FILENAME_BASE}}.out\", \"w\", stdout);"
        ],
        "description": "freopen template"
    },
    "fastio": {
        "prefix": "```fio",
        "body": "ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
        "description": "close sync to get faster io"
    },
    "superfastio": {
        "prefix": "```sfio",
        "body": [
            "const auto rd = [](auto &x) {",
            "    static bool f;",
            "    static char ch;",
            "    for (f = 0, ch = gc(); !isdigit(ch); ch = gc()) (ch != '-' || (f = 1));",
            "    for (x = 0; isdigit(ch); ch = gc()) x = (x << 3) + (x << 1) + (ch ^ 48);",
            "    f && (x = -x);",
            "};",
            "const auto wt = [](auto x) {",
            "    static signed num[128] = {};",
            "    x >= 0 || (pc('-'), (x = -x));",
            "    do num[++num[0]] = x % 10;",
            "    while (x /= 10);",
            "    while (num[0]) pc(num[num[0]--] + '0');",
            "};",
            "const auto rds = [](auto &...x) { (rd(x), ...); };",
            "const auto wts = [](const auto &...x) { ((wt(x), pc(' ')), ...), pc('\\n'); };",
        ],
        "description": "get super faster io"
    },
    "superdefine": {
        "prefix": "```bint",
        "body": [
            "using ull = unsigned long long;",
            "using i128 = __int128;",
            "using pull = pair<ull, ull>;",
            "using pi128 = pair<i128, i128>;",
        ],
        "description": "superdefine"
    },
    "sgtdef": {
        "prefix": "```sgtdef",
        "body": [
            "TEMPTK struct SegmentTree {",
            "    vector<T> tr;",
            "    SegmentTree(int n) : tr((n + 10) << 2) {}",
            "};",
        ]
    },
    "qpow": {
        "prefix": "```qpow",
        "body": [
            "ll qpow(ll x, ll y) {",
            "    ll res = 1;",
            "    for (; y; y >>= 1, mul(x, x)) ((y & 1) && mul(res, x));",
            "    return res;",
            "}",
            "ll inv(ll x) { return qpow(x, P - 2); }",
        ]
    },
    "comb": {
        "prefix": "```comb",
        "body": [
            "ll qpow(ll x, ll y) {",
            "    ll res = 1;",
            "    for (; y; y >>= 1, mul(x, x)) ((y & 1) && mul(res, x));",
            "    return res;",
            "}",
            "ll inv(ll x) { return qpow(x, P - 2); }",
            "TEMPTK struct Combine {",
            "    vector<T> fac, ifac;",
            "    Combine(int N) : fac(N + 1), ifac(N + 1) {",
            "        fac[0] = 1;",
            "        rep(i, 1, N) fac[i] = fac[i - 1] * i % P;",
            "        ifac[N] = inv(fac[N]);",
            "        per(i, N - 1, 0) ifac[i] = ifac[i + 1] * (i + 1) % P;",
            "    }",
            "    T C(int n, int m) { return n < m || m < 0 ? 0 : fac[n] * ifac[m] % P * ifac[n - m] % P; }",
            "    T L(int n, int m) {",
            "        if (n < m || m < 0) return 0;",
            "        T res = 1;",
            "        while (m) mul(res, C(n % P, m % P)), n /= P, m /= P;",
            "        return res;",
            "    }",
            "};",
        ]
    },
    "graph": {
        "prefix": "```graph",
        "body": [
            "#define go(u, i) for (int i = head[u]; i; i = e[i].nxt)",
            "struct edge {",
            "    int v, w, nxt;",
            "    edge(int v = 0, int w = 0, int nxt = 0) : v(v), w(w), nxt(nxt) {}",
            "};",
            "vi head;",
            "vector<edge> e(2);",
            "inline void addedge(int u, int v, int w) { e.eb(v, w, head[u]), head[u] = SZ(e) - 1; }",
            "inline void adde(int u, int v, int w) { addedge(u, v, w), addedge(v, u, w); }",
        ]
    },
    "tree in pbds": {
        "prefix": "```pset",
        "body": "TEMPTK using pset = pbds::tree<T, pbds::null_type, less<T>, pbds::rb_tree_tag, pbds::tree_order_statistics_node_update>;"
    },
    "modint": {
        "prefix": "```mint",
        "body": [
            "struct mint {",
            "    static constexpr ll P = 998244353;",
            "    int v;",
            "    mint(int x = 0) : v((x %= P) += x >> 31 & P) {}",
            "    friend mint &operator+=(mint &x, const mint &y) { return (x.v += y.v) >= P ? x.v -= P, x : x; }",
            "    friend mint &operator-=(mint &x, const mint &y) { return (x.v -= y.v) += x.v >> 31 & P, x; }",
            "    friend mint &operator*=(mint &x, const mint &y) { return (x.v *= y.v) %= P, x; }",
            "    friend mint &operator/=(mint &x, const mint &y) { return x.v % y.v ? (x.v *= inv(y).v) %= P : x.v /= y.v, x; }",
            "    friend mint &operator%=(mint &x, const int y) { return x.v %= y, x; }",
            "    friend mint operator+(mint x, const mint &y) { return x += y; }",
            "    friend mint operator-(mint x, const mint &y) { return x -= y; }",
            "    friend mint operator*(mint x, const mint &y) { return x *= y; }",
            "    friend mint operator/(mint x, const mint &y) { return x /= y; }",
            "    friend mint operator%(mint x, const int y) { return x %= y; }",
            "    friend istream &operator>>(istream &in, mint &x) { return in >> x.v, (x.v %= P) += x.v >> 31 & P, in; }",
            "    friend ostream &operator<<(ostream &out, const mint &x) { return out << x.v; }",
            "    friend mint &operator++(mint &x) { return x += 1; }",
            "    friend mint &operator--(mint &x) { return x -= 1; }",
            "    friend mint operator++(mint &x, signed) {",
            "        const mint y = x;",
            "        return ++x, y;",
            "    }",
            "    friend mint operator--(mint &x, signed) {",
            "        const mint y = x;",
            "        return --x, y;",
            "    }",
            "    friend mint qpow(mint x, int y) {",
            "        mint res = 1;",
            "        for (; y; y >>= 1, x *= x) ((y & 1) && (res *= x, 0));",
            "        return res;",
            "    }",
            "    friend mint inv(mint x) { return qpow(x, P - 2); }",
            "    friend mint qmul(mint x, const mint &y) { return (x.v = (ull)x.v * y.v - (ull)((ld)x.v / P * y.v) * P) += x.v >> 31 & P, x; }",
            "    mint mul(const mint &y) { return qmul(*this, y); }",
            "};",
        ]
    }
}